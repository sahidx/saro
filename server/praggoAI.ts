import { GoogleGenAI } from "@google/genai";
import { db } from "./db";
import { praggoAIKeys, praggoAIUsage } from "@shared/schema";
import { eq, and, sql } from "drizzle-orm";

// Praggo AI - Bangladeshi Educational AI Assistant
// Intelligent API key rotation system with database tracking

class PraggoAIService {
  private static instance: PraggoAIService;
  private apiKeys: Array<{ keyName: string; keyValue: string; keyIndex: number; }> = [];
  private currentKeyIndex = 0;
  private readonly maxRetries = 7; // Support up to 7 API keys

  constructor() {
    this.initializeAPIKeys();
  }

  static getInstance(): PraggoAIService {
    if (!PraggoAIService.instance) {
      PraggoAIService.instance = new PraggoAIService();
    }
    return PraggoAIService.instance;
  }

  // Initialize API keys from environment
  private initializeAPIKeys() {
    const keyNames = [
      'GEMINI_API_KEY_1',
      'GEMINI_API_KEY_2', 
      'GEMINI_API_KEY_3',
      'GEMINI_API_KEY_4',
      'GEMINI_API_KEY_5',
      'GEMINI_API_KEY_6',
      'GEMINI_API_KEY_7'
    ];

    this.apiKeys = keyNames
      .map((keyName, index) => ({
        keyName,
        keyValue: process.env[keyName] || '',
        keyIndex: index
      }))
      .filter(key => key.keyValue && key.keyValue.trim() !== '');

    console.log(`üéØ Praggo AI Keys configured: ${this.apiKeys.length} keys available`);
    
    // Initialize database keys if they don't exist
    this.initializeDatabaseKeys();
  }

  // Initialize API keys in database
  private async initializeDatabaseKeys() {
    try {
      for (const key of this.apiKeys) {
        const existingKey = await db.select().from(praggoAIKeys)
          .where(eq(praggoAIKeys.keyName, key.keyName)).limit(1);
        
        if (existingKey.length === 0) {
          await db.insert(praggoAIKeys).values({
            keyName: key.keyName,
            keyIndex: key.keyIndex,
            status: 'active',
            isEnabled: true,
            dailyUsageCount: 0
          });
          console.log(`‚úÖ Initialized Praggo AI key: ${key.keyName}`);
        }
      }
    } catch (error) {
      console.log('üìù Database not ready for Praggo AI keys initialization, will use memory only');
    }
  }

  // Get current active API key
  private getCurrentKey(): { keyName: string; keyValue: string; keyIndex: number; } | null {
    if (this.apiKeys.length === 0) {
      return null;
    }
    return this.apiKeys[this.currentKeyIndex];
  }

  // Create Gemini client with current key
  private createGeminiClient(): GoogleGenAI | null {
    const currentKey = this.getCurrentKey();
    if (!currentKey) {
      console.warn('‚ö†Ô∏è No Praggo AI keys configured');
      return null;
    }
    
    console.log(`ü§ñ Using Praggo AI Key #${currentKey.keyIndex + 1}/${this.apiKeys.length} (${currentKey.keyName})`);
    return new GoogleGenAI({ apiKey: currentKey.keyValue });
  }

  // Rotate to next available API key
  private async rotateToNextKey(): Promise<boolean> {
    if (this.apiKeys.length <= 1) {
      console.warn('‚ö†Ô∏è No additional Praggo AI keys available for rotation');
      return false;
    }

    const oldKey = this.getCurrentKey();
    
    // Mark current key as quota exceeded in database
    if (oldKey) {
      try {
        await db.update(praggoAIKeys)
          .set({ 
            status: 'quota_exceeded',
            quotaResetDate: new Date(Date.now() + 24 * 60 * 60 * 1000) // Reset tomorrow
          })
          .where(eq(praggoAIKeys.keyName, oldKey.keyName));
      } catch (error) {
        console.log('üìù Database update failed, continuing with memory rotation');
      }
    }

    const oldIndex = this.currentKeyIndex;
    this.currentKeyIndex = (this.currentKeyIndex + 1) % this.apiKeys.length;
    const newKey = this.getCurrentKey();
    
    console.log(`üîÑ Praggo AI rotated from Key #${oldIndex + 1} to #${this.currentKeyIndex + 1}`);
    return true;
  }

  // Check if error is quota/rate limit related
  private isQuotaError(error: any): boolean {
    const errorMessage = error?.message?.toLowerCase() || '';
    const errorStatus = error?.status || error?.code;
    
    return (
      errorMessage.includes('quota') ||
      errorMessage.includes('rate limit') ||
      errorMessage.includes('limit exceeded') ||
      errorMessage.includes('resource exhausted') ||
      errorStatus === 429 ||
      errorStatus === 403
    );
  }

  // Log API usage to database
  private async logUsage(
    userId: string,
    userRole: 'teacher' | 'student',
    requestType: 'generate_questions' | 'solve_doubt',
    subject: 'chemistry' | 'ict',
    success: boolean,
    keyUsed?: string,
    errorMessage?: string,
    processingTime?: number,
    promptLength?: number,
    responseLength?: number
  ) {
    try {
      await db.insert(praggoAIUsage).values({
        userId,
        userRole,
        requestType,
        keyUsed: keyUsed || 'none',
        subject,
        success,
        errorMessage,
        processingTime,
        promptLength,
        responseLength
      });

      // Update key usage count
      if (keyUsed && success) {
        await db.update(praggoAIKeys)
          .set({ 
            dailyUsageCount: sql`${praggoAIKeys.dailyUsageCount} + 1`,
            lastUsed: new Date()
          })
          .where(eq(praggoAIKeys.keyName, keyUsed));
      }
    } catch (error) {
      console.log('üìù Usage logging failed, continuing without database tracking');
    }
  }

  // Main API call method with rotation and error handling
  async makeAPICall(
    prompt: string,
    userId: string,
    userRole: 'teacher' | 'student',
    requestType: 'generate_questions' | 'solve_doubt',
    subject: 'chemistry' | 'ict'
  ): Promise<string> {
    const startTime = Date.now();
    let attempt = 0;
    let lastError: any = null;
    const promptLength = prompt.length;

    while (attempt < this.maxRetries && attempt < this.apiKeys.length) {
      const currentKey = this.getCurrentKey();
      
      if (!currentKey) {
        const errorMsg = 'Praggo AI ‡¶è‡¶∞ ‡¶ï‡ßã‡¶®‡ßã API key ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá GEMINI_API_KEY_1, GEMINI_API_KEY_2 ‡¶á‡¶§‡ßç‡¶Ø‡¶æ‡¶¶‡¶ø ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®‡•§';
        await this.logUsage(userId, userRole, requestType, subject, false, undefined, errorMsg);
        throw new Error(errorMsg);
      }

      const genAI = this.createGeminiClient();
      if (!genAI) {
        attempt++;
        continue;
      }

      try {
        console.log(`üéØ Praggo AI attempt ${attempt + 1}/${this.maxRetries}`);
        
        const response = await genAI.models.generateContent({
          model: "gemini-2.0-flash-exp",
          contents: [{ role: "user", parts: [{ text: prompt }] }],
        });

        const result = response.response.text();
        const processingTime = Date.now() - startTime;
        const responseLength = result.length;

        // Log successful usage
        await this.logUsage(
          userId, userRole, requestType, subject, true, 
          currentKey.keyName, undefined, processingTime, promptLength, responseLength
        );

        return result;

      } catch (error: any) {
        lastError = error;
        const processingTime = Date.now() - startTime;
        
        console.log(`‚ùå Praggo AI Key #${currentKey.keyIndex + 1} failed:`, error.message);

        // Log failed usage
        await this.logUsage(
          userId, userRole, requestType, subject, false,
          currentKey.keyName, error.message, processingTime, promptLength
        );

        if (this.isQuotaError(error)) {
          console.log(`üîÑ Quota exceeded, rotating Praggo AI key...`);
          await this.rotateToNextKey();
          attempt++;
          continue;
        } else {
          // Non-quota error, don't retry
          break;
        }
      }
    }

    // All keys exhausted or non-quota error
    let errorMessage = '';
    if (lastError?.message?.includes('exhausted') || attempt >= this.apiKeys.length) {
      errorMessage = '‡¶Ü‡¶ú‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Praggo AI ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡ßá‡¶∞ ‡¶∏‡ßÄ‡¶Æ‡¶æ ‡¶∂‡ßá‡¶∑! ‡¶Ü‡¶ó‡¶æ‡¶Æ‡ßÄ‡¶ï‡¶æ‡¶≤ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§';
    } else if (this.isQuotaError(lastError)) {
      errorMessage = 'Praggo AI ‡¶è‡¶∞ ‡¶∏‡¶ï‡¶≤ API key ‡¶è‡¶∞ ‡¶∏‡ßÄ‡¶Æ‡¶æ ‡¶™‡ßÇ‡¶∞‡ßç‡¶£! ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ‡¶ï‡ßç‡¶∑‡¶£ ‡¶™‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§';
    } else {
      errorMessage = lastError?.message || 'Praggo AI ‡¶∏‡ßá‡¶¨‡¶æ‡¶Ø‡¶º ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§';
    }

    throw new Error(errorMessage);
  }

  // Generate questions with enhanced Bangladeshi context
  async generateQuestions(
    subject: string,
    examType: string,
    classLevel: string,
    chapter: string,
    questionType: string,
    difficulty: string,
    count: number,
    userId: string,
    userRole: 'teacher' | 'student'
  ): Promise<any> {
    
    if (this.apiKeys.length === 0) {
      // Return sample questions if no API key
      console.warn('‚ö†Ô∏è No Praggo AI keys configured, returning sample questions');
      const sampleQuestions = [];
      for (let i = 0; i < count; i++) {
        sampleQuestions.push({
          questionText: `‡¶®‡¶Æ‡ßÅ‡¶®‡¶æ ${subject === 'chemistry' ? '‡¶∞‡¶∏‡¶æ‡¶Ø‡¶º‡¶®' : 'ICT'} ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ${i + 1} - ${chapter} (${difficulty} ‡¶∏‡ßç‡¶§‡¶∞)`,
          questionType: questionType,
          options: questionType === 'mcq' ? ['‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶ï', '‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶ñ', '‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶ó', '‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶ò'] : null,
          correctAnswer: questionType === 'mcq' ? '‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶ï' : null,
          answer: 'Praggo AI ‡¶∏‡¶†‡¶ø‡¶ï ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶¶‡¶æ‡¶® ‡¶ï‡¶∞‡¶¨‡ßá‡•§ API key ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§',
          marks: questionType === 'creative' ? 10 : questionType === 'cq' ? 2 : 1
        });
      }
      return sampleQuestions;
    }

    const subjectBangla = subject === 'chemistry' ? '‡¶∞‡¶∏‡¶æ‡¶Ø‡¶º‡¶®' : '‡¶§‡¶•‡ßç‡¶Ø ‡¶ì ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶™‡ßç‡¶∞‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§‡¶ø';
    const examTypeBangla = examType === 'academic' ? '‡¶è‡¶ï‡¶æ‡¶°‡ßá‡¶Æ‡¶ø‡¶ï' : '‡¶≠‡¶∞‡ßç‡¶§‡¶ø ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ';
    const classLevelBangla = classLevel === '9-10' ? '‡¶®‡¶¨‡¶Æ-‡¶¶‡¶∂‡¶Æ ‡¶∂‡ßç‡¶∞‡ßá‡¶£‡¶ø' : '‡¶è‡¶ï‡¶æ‡¶¶‡¶∂-‡¶¶‡ßç‡¶¨‡¶æ‡¶¶‡¶∂ ‡¶∂‡ßç‡¶∞‡ßá‡¶£‡¶ø (HSC)';
    
    let difficultyLevels = '';
    if (difficulty === 'mixed') {
      difficultyLevels = '‡¶∏‡¶π‡¶ú, ‡¶Æ‡¶ß‡ßç‡¶Ø‡¶Æ ‡¶ì ‡¶ú‡¶ü‡¶ø‡¶≤ ‡¶∏‡ßç‡¶§‡¶∞‡ßá‡¶∞ ‡¶Æ‡¶ø‡¶∂‡ßç‡¶∞‡¶£';
    } else if (difficulty === 'easy') {
      difficultyLevels = '‡¶∏‡¶π‡¶ú ‡¶∏‡ßç‡¶§‡¶∞‡ßá‡¶∞';
    } else if (difficulty === 'medium') {
      difficultyLevels = '‡¶Æ‡¶ß‡ßç‡¶Ø‡¶Æ ‡¶∏‡ßç‡¶§‡¶∞‡ßá‡¶∞';
    } else {
      difficultyLevels = '‡¶ú‡¶ü‡¶ø‡¶≤ ‡¶∏‡ßç‡¶§‡¶∞‡ßá‡¶∞';
    }

    // Enhanced Bangladeshi context prompt
    const prompt = `‡¶Ü‡¶™‡¶®‡¶ø "Praggo AI" - ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑‡¶≠‡¶æ‡¶¨‡ßá ‡¶°‡¶ø‡¶ú‡¶æ‡¶á‡¶® ‡¶ï‡¶∞‡¶æ ‡¶è‡¶ï‡¶ü‡¶ø AI ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï‡•§

üéØ Chemistry & ICT Care by Belal Sir ‡¶ï‡ßã‡¶ö‡¶ø‡¶Ç ‡¶∏‡ßá‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ${count}‡¶ü‡¶ø ${difficultyLevels} ${subjectBangla} ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®‡•§

üìö ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶¨‡¶ø‡¶¨‡¶∞‡¶£:
- ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º: ${subjectBangla} (${subject})
- ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ‡¶∞ ‡¶ß‡¶∞‡¶®: ${examTypeBangla}
- ‡¶∂‡ßç‡¶∞‡ßá‡¶£‡¶ø: ${classLevelBangla}
- ‡¶Ö‡¶ß‡ßç‡¶Ø‡¶æ‡¶Ø‡¶º/‡¶ü‡¶™‡¶ø‡¶ï: ${chapter}
- ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶ß‡¶∞‡¶®: ${questionType}
- ‡¶ï‡¶†‡¶ø‡¶®‡¶§‡¶æ‡¶∞ ‡¶∏‡ßç‡¶§‡¶∞: ${difficultyLevels}

üáßüá© NCTB ‡¶ï‡¶æ‡¶∞‡¶ø‡¶ï‡ßÅ‡¶≤‡¶æ‡¶Æ ‡¶ì ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ‡¶¨‡ßç‡¶Ø‡¶¨‡¶∏‡ßç‡¶•‡¶æ ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ:

${subject === 'chemistry' ? `üß™ ‡¶∞‡¶∏‡¶æ‡¶Ø‡¶º‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶®‡¶æ:
- ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ NCTB ‡¶™‡¶æ‡¶†‡ßç‡¶Ø‡¶¨‡¶á ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ
- ‡¶∞‡¶æ‡¶∏‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡¶ï ‡¶∏‡ßÇ‡¶§‡ßç‡¶∞ ‡¶ì ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º
- ‡¶¶‡ßà‡¶®‡¶®‡ßç‡¶¶‡¶ø‡¶® ‡¶ú‡ßÄ‡¶¨‡¶®‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡¶ø‡¶§ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£
- HSC/SSC ‡¶¨‡ßã‡¶∞‡ßç‡¶° ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶ß‡¶æ‡¶∞‡¶æ ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶∞‡¶£
- ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßÄ ‡¶™‡ßç‡¶∞‡ßá‡¶ï‡ßç‡¶∑‡¶æ‡¶™‡¶ü‡ßá‡¶∞ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£` : `üíª ICT ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶®‡¶æ:
- ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü‡¶æ‡¶≤ ‡¶Ø‡ßÅ‡¶ó‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡ßá‡¶ï‡ßç‡¶∑‡¶æ‡¶™‡¶ü
- ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ‡¶ø‡¶Ç, ‡¶°‡ßá‡¶ü‡¶æ‡¶¨‡ßá‡¶∏, ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï
- ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ø‡¶ï ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶ì ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®
- ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§‡¶ø ‡¶ñ‡¶æ‡¶§‡ßá‡¶∞ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£
- HSC ICT ‡¶¨‡ßã‡¶∞‡ßç‡¶° ‡¶∏‡¶ø‡¶≤‡ßá‡¶¨‡¶æ‡¶∏ ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ`}

üìã JSON ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º ‡¶â‡¶§‡ßç‡¶§‡¶∞):
${questionType === 'mcq' ? 'MCQ ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü:' : questionType === 'cq' ? 'CQ ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü:' : '‡¶∏‡ßÉ‡¶ú‡¶®‡¶∂‡ßÄ‡¶≤ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü:'}
[{"questionText": "‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®", "questionType": "${questionType}", ${questionType === 'mcq' ? '"options": ["‡¶ï) ...", "‡¶ñ) ...", "‡¶ó) ...", "‡¶ò) ..."], "correctAnswer": "‡¶ï) ...",' : '"options": null, "correctAnswer": null,'} "answer": "‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶â‡¶§‡ßç‡¶§‡¶∞", "marks": ${questionType === 'creative' ? '10' : questionType === 'cq' ? '2' : '1'}}]`;

    try {
      const content = await this.makeAPICall(
        prompt, userId, userRole, 'generate_questions', subject as 'chemistry' | 'ict'
      );
      
      console.log("Praggo AI response for Bangladesh questions:", content);
      
      // Parse JSON response
      let jsonMatch = content.match(/\[[\s\S]*\]/);
      
      if (!jsonMatch) {
        jsonMatch = content.match(/```json\n?([\s\S]*?)\n?```/);
        if (jsonMatch) {
          jsonMatch = [jsonMatch[1]];
        }
      }
      
      if (jsonMatch) {
        try {
          return JSON.parse(jsonMatch[0]);
        } catch (parseError) {
          console.error('JSON parsing failed:', parseError);
          throw new Error('Praggo AI ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶†‡¶ø‡¶ï ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡ßá ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§');
        }
      } else {
        throw new Error('Praggo AI ‡¶•‡ßá‡¶ï‡ßá JSON ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡ßá ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§');
      }
      
    } catch (error: any) {
      console.error('Praggo AI question generation error:', error);
      throw error;
    }
  }

  // Solve student doubts with NCTB context
  async solveDoubt(
    question: string,
    subject: string,
    userId: string,
    userRole: 'student'
  ): Promise<string> {
    
    if (this.apiKeys.length === 0) {
      return `ü§ñ Praggo AI ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® (‡¶°‡ßá‡¶Æ‡ßã ‡¶Æ‡ßã‡¶°)\n\n‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ${subject === 'chemistry' ? '‡¶∞‡¶∏‡¶æ‡¶Ø‡¶º‡¶®' : 'ICT'} ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®: "${question}"\n\n‡¶è‡¶ü‡¶ø Praggo AI ‡¶¶‡ßç‡¶¨‡¶æ‡¶∞‡¶æ ‡¶™‡ßç‡¶∞‡¶¶‡¶§‡ßç‡¶§ ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶π‡¶¨‡ßá‡•§ ‡¶∏‡¶†‡¶ø‡¶ï AI ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶™‡ßá‡¶§‡ßá API keys ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§`;
    }

    const subjectBangla = subject === 'chemistry' ? '‡¶∞‡¶∏‡¶æ‡¶Ø‡¶º‡¶®' : '‡¶§‡¶•‡ßç‡¶Ø ‡¶ì ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶™‡ßç‡¶∞‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§‡¶ø';

    const prompt = `‡¶Ü‡¶™‡¶®‡¶ø "Praggo AI" - ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑‡¶≠‡¶æ‡¶¨‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø AI ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï‡•§

üéì Chemistry & ICT Care by Belal Sir ‡¶ï‡ßã‡¶ö‡¶ø‡¶Ç ‡¶∏‡ßá‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡ßá‡¶∞ ‡¶è‡¶ï‡¶ú‡¶® ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑‡¶ú‡ßç‡¶û ${subjectBangla} ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶ï ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶®‡•§

üìù ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ‡¶∞‡ßç‡¶•‡ßÄ‡¶∞ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®: ${question}

üáßüá© ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ NCTB ‡¶ï‡¶æ‡¶∞‡¶ø‡¶ï‡ßÅ‡¶≤‡¶æ‡¶Æ ‡¶ì ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ‡¶¨‡ßç‡¶Ø‡¶¨‡¶∏‡ßç‡¶•‡¶æ ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£, ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ‡¶Æ‡ßÇ‡¶≤‡¶ï ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶™‡ßç‡¶∞‡¶¶‡¶æ‡¶® ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶Ø‡¶æ‡¶§‡ßá ‡¶∞‡¶Ø‡¶º‡ßá‡¶õ‡ßá:

${subject === 'chemistry' ? `üß™ ‡¶∞‡¶∏‡¶æ‡¶Ø‡¶º‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø:
- ‡¶ß‡¶æ‡¶™‡ßá ‡¶ß‡¶æ‡¶™‡ßá ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶∏‡¶π ‡¶∞‡¶æ‡¶∏‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡¶ï ‡¶∏‡¶Æ‡ßÄ‡¶ï‡¶∞‡¶£
- ‡¶Ü‡¶£‡¶¨‡¶ø‡¶ï ‡¶∏‡ßÇ‡¶§‡ßç‡¶∞ ‡¶ì ‡¶ï‡¶æ‡¶†‡¶æ‡¶Æ‡ßã ‡¶ö‡¶ø‡¶§‡ßç‡¶∞ (‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡ßá)
- ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶¶‡ßà‡¶®‡¶®‡ßç‡¶¶‡¶ø‡¶® ‡¶ú‡ßÄ‡¶¨‡¶®‡ßá‡¶∞ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£
- HSC/SSC ‡¶¨‡ßã‡¶∞‡ßç‡¶° ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡ßá‡¶ï‡ßç‡¶∑‡¶æ‡¶™‡¶ü‡ßá ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ
- ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶§‡ßç‡¶§‡¶æ ‡¶ì ‡¶™‡¶∞‡¶ø‡¶¨‡ßá‡¶∂‡¶ó‡¶§ ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º‡¶æ‡¶¨‡¶≤‡ßÄ
- ‡¶Ö‡¶§‡¶ø‡¶∞‡¶ø‡¶ï‡ßç‡¶§ ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶® ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂` : `üíª ICT ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø:
- ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ø‡¶ï ‡¶ï‡ßã‡¶° ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ (‡¶Ø‡¶¶‡¶ø ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶® ‡¶π‡¶Ø‡¶º)
- ‡¶™‡ßç‡¶∞‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§‡¶ø‡¶ó‡¶§ ‡¶ß‡¶æ‡¶∞‡¶£‡¶æ‡¶∞ ‡¶∏‡¶π‡¶ú ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ
- ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§‡¶ø ‡¶ñ‡¶æ‡¶§‡ßá‡¶∞ ‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨ ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ó
- HSC ICT ‡¶∏‡¶ø‡¶≤‡ßá‡¶¨‡¶æ‡¶∏ ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ ‡¶¨‡¶ø‡¶∂‡¶¶ ‡¶¨‡¶∞‡ßç‡¶£‡¶®‡¶æ
- ‡¶≠‡¶¨‡¶ø‡¶∑‡ßç‡¶Ø‡ßé ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó
- ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶∞‡¶ì ‡¶∞‡¶ø‡¶∏‡ßã‡¶∞‡ßç‡¶∏`}

‚ú® ‡¶â‡¶§‡ßç‡¶§‡¶∞‡¶ü‡¶ø ‡¶Ö‡¶¨‡¶∂‡ßç‡¶Ø‡¶á:
- ‡¶∏‡¶π‡¶ú ‡¶ì ‡¶¨‡ßã‡¶ß‡¶ó‡¶Æ‡ßç‡¶Ø ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®
- ‡¶ß‡¶æ‡¶™‡ßá ‡¶ß‡¶æ‡¶™‡ßá ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®
- ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßÄ ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ‡¶∞‡ßç‡¶•‡ßÄ‡¶¶‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡¶æ‡¶∏‡¶ô‡ßç‡¶ó‡¶ø‡¶ï ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡¶¶‡¶ø‡¶®
- ‡¶â‡ßé‡¶∏‡¶æ‡¶π‡¶Æ‡ßÇ‡¶≤‡¶ï ‡¶ì ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶£‡ßÄ‡¶Ø‡¶º ‡¶ü‡ßã‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®

üéØ Praggo AI ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®:`;

    try {
      const result = await this.makeAPICall(
        prompt, userId, userRole, 'solve_doubt', subject as 'chemistry' | 'ict'
      );
      
      return result;
    } catch (error: any) {
      console.error('Praggo AI doubt solving error:', error);
      return `ü§ñ Praggo AI ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® (‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø)\n\n‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ${subjectBangla} ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®: "${question}"\n\n‚ùå ${error.message}\n\n‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ‡¶ï‡ßç‡¶∑‡¶£ ‡¶™‡¶∞ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶¨‡¶æ ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶ï‡ßá‡¶∞ ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶®‡¶ø‡¶®‡•§`;
    }
  }

  // Get API usage statistics
  async getUsageStats(userId: string): Promise<any> {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const usage = await db.select()
        .from(praggoAIUsage)
        .where(
          and(
            eq(praggoAIUsage.userId, userId),
            sql`${praggoAIUsage.createdAt} >= ${today}`
          )
        );
        
      return {
        todayUsage: usage.length,
        successfulCalls: usage.filter(u => u.success).length,
        failedCalls: usage.filter(u => !u.success).length,
        questionsGenerated: usage.filter(u => u.requestType === 'generate_questions').length,
        doubtsResolved: usage.filter(u => u.requestType === 'solve_doubt').length
      };
    } catch (error) {
      return {
        todayUsage: 0,
        successfulCalls: 0,
        failedCalls: 0,
        questionsGenerated: 0,
        doubtsResolved: 0
      };
    }
  }
}

// Export singleton instance
export const praggoAI = PraggoAIService.getInstance();